

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyfor package &mdash; pyfor 0.2.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> pyfor
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">pyfor package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pyfor.clip_funcs">pyfor.clip_funcs module</a></li>
<li><a class="reference internal" href="#module-pyfor.cloud">pyfor.cloud module</a></li>
<li><a class="reference internal" href="#module-pyfor.filter">pyfor.filter module</a></li>
<li><a class="reference internal" href="#module-pyfor.gisexport">pyfor.gisexport module</a></li>
<li><a class="reference internal" href="#module-pyfor.plot">pyfor.plot module</a></li>
<li><a class="reference internal" href="#module-pyfor.rasterizer">pyfor.rasterizer module</a></li>
<li><a class="reference internal" href="#pyfor-test-module">pyfor.test module</a></li>
<li><a class="reference internal" href="#module-pyfor">Module contents</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyfor</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>pyfor package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/source/pyfor.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pyfor-package">
<h1>pyfor package<a class="headerlink" href="#pyfor-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyfor.clip_funcs">
<span id="pyfor-clip-funcs-module"></span><h2>pyfor.clip_funcs module<a class="headerlink" href="#module-pyfor.clip_funcs" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyfor.clip_funcs.poly_clip">
<code class="descclassname">pyfor.clip_funcs.</code><code class="descname">poly_clip</code><span class="sig-paren">(</span><em>cloud</em>, <em>poly</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.clip_funcs.poly_clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices within a given polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cloud</strong> – A cloud object.</li>
<li><strong>poly</strong> – A shapely Polygon, with coordinates in the same CRS as the point cloud (for best results).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A 1D numpy array of indices corresponding to points within the given polygon.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyfor.clip_funcs.ray_trace">
<code class="descclassname">pyfor.clip_funcs.</code><code class="descname">ray_trace</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>poly</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.clip_funcs.ray_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>A numba implementation of the ray tracing algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – A 1D numpy array of x coordinates.</li>
<li><strong>y</strong> – A 1D numpy array of y coordinates.</li>
<li><strong>poly</strong> – The coordinates of a polygon as a numpy array (i.e. from geo_json[‘coordinates’]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyfor.clip_funcs.square_clip">
<code class="descclassname">pyfor.clip_funcs.</code><code class="descname">square_clip</code><span class="sig-paren">(</span><em>cloud</em>, <em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.clip_funcs.square_clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clips a square from a tuple describing the position of the square.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>las_xy</strong> – A N x 2 numpy array of x and y coordinates, x in</td>
</tr>
</tbody>
</table>
<p>column 0
:param bounds: A tuple of length 4, min y and max y coordinates of the square.
:return: A boolean mask, true is within the square</p>
</dd></dl>

</div>
<div class="section" id="module-pyfor.cloud">
<span id="pyfor-cloud-module"></span><h2>pyfor.cloud module<a class="headerlink" href="#module-pyfor.cloud" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyfor.cloud.Cloud">
<em class="property">class </em><code class="descclassname">pyfor.cloud.</code><code class="descname">Cloud</code><span class="sig-paren">(</span><em>las</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The cloud object is the integral unit of pyfor, and is where most of the action takes place. Many of the following     attributes are convenience functions for other classes and modules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>las</strong> – One of either: a string representing the path to a las (or laz) file or a CloudData object.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyfor.cloud.Cloud.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>las</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.chm">
<code class="descname">chm</code><span class="sig-paren">(</span><em>cell_size</em>, <em>interp_method=None</em>, <em>pit_filter=None</em>, <em>kernel_size=3</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.chm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Raster object of the maximum z value in each cell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cell_size</strong> – The cell size for the returned raster in the same units as the parent Cloud or las file.</li>
<li><strong>interp_method</strong> – The interpolation method to fill in NA values of the produced canopy height model, one         of either “nearest”, “cubic”, or “linear”</li>
<li><strong>pit_filter</strong> – If “median” passes a median filter over the produced canopy height model.</li>
<li><strong>kernel_size</strong> – The kernel size of the median filter, must be an odd integer.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A Raster object of the canopy height model.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.clip">
<code class="descname">clip</code><span class="sig-paren">(</span><em>poly</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clips the point cloud to the provided shapely polygon using a ray casting algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>poly</strong> – A shapely polygon in the same CRS as the Cloud.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A new cloud object clipped to the provided polygon.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyfor.cloud.Cloud.convex_hull">
<code class="descname">convex_hull</code><a class="headerlink" href="#pyfor.cloud.Cloud.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the convex hull of the 2d plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A single-element geoseries of the convex hull.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>min</em>, <em>max</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters a cloud object for a given dimension <strong>in place</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>min</strong> – Minimum dimension to retain.</li>
<li><strong>max</strong> – Maximum dimension to retain.</li>
<li><strong>dim</strong> – The dimension of interest as a string. For example “z”. This corresponds to a column label in         self.las.points dataframe.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.grid">
<code class="descname">grid</code><span class="sig-paren">(</span><em>cell_size</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Grid object for this Cloud given a cell size. The Grid is generally used to compute Raster objects
See the documentation for Grid for more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cell_size</strong> – The resolution of the plot in the same units as the input file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Grid object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.iplot3d">
<code class="descname">iplot3d</code><span class="sig-paren">(</span><em>max_points=30000</em>, <em>point_size=0.5</em>, <em>dim='z'</em>, <em>colorscale='Viridis'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.iplot3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the 3d point cloud in a compatible version for Jupyter notebooks using Plotly as a backend. If         max_points exceeds 30,000, the point cloud is downsampled using a uniform random distribution by default.         This can be changed using the max_points argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>max_points</strong> – The maximum number of points to render.</li>
<li><strong>point_size</strong> – The point size of the rendered point cloud.</li>
<li><strong>dim</strong> – The dimension on which to color (i.e. “z”, “intensity”, etc.)</li>
<li><strong>colorscale</strong> – The Plotly colorscale with which to color.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>cell_size</em>, <em>num_windows=7</em>, <em>dh_max=2.5</em>, <em>dh_0=1</em>, <em>interp_method='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes this cloud object <strong>in place</strong> by generating a DEM using the default filtering algorithm  and         subtracting the underlying ground elevation. This uses a grid-based progressive morphological filter developed         in Zhang et al. (2003).</p>
<p>This algorithm is actually implemented on a raster of the minimum Z value in each cell, but is included in         the Cloud object as a convenience wrapper. Its implementation involves creating a bare earth model and then         subtracting the underlying ground from each point’s elevation value.</p>
<p>If you would like to create a bare earth model, look instead toward Grid.ground_filter.</p>
<p>Note that this current implementation is best suited for larger tiles. Best practices suggest creating a BEM         at the largest scale possible first, and using that to normalize plot-level point clouds in a production         setting. This sets self.normalized to True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cell_size</strong> – The cell_size at which to rasterize the point cloud into bins, in the same units as the         input point cloud.</li>
<li><strong>num_windows</strong> – The number of windows to consider.</li>
<li><strong>dh_max</strong> – The maximum height threshold.</li>
<li><strong>dh_0</strong> – The null height threshold.</li>
<li><strong>interp_method</strong> – The interpolation method used to fill in missing values after the ground filtering         takes place. One of any: “nearest”, “linear”, or “cubic”.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>cell_size=1</em>, <em>cmap='viridis'</em>, <em>return_plot=False</em>, <em>block=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a basic canopy height model of the Cloud object. This is mainly a convenience function for         rasterizer.Grid.plot, check that method docstring for more information and more robust usage cases (i.e.         pit filtering and interpolation methods).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vmin</strong><strong> or </strong><strong>vmax is not given</strong><strong>, </strong><strong>they are initialized from the minimum and maximum value respectively of the first input processed. That is</strong><strong>, </strong><strong>__call__</strong><strong>(</strong><strong>A</strong><strong>) </strong><strong>calls autoscale_None</strong><strong>(</strong><strong>A</strong><strong>)</strong><strong> If clip _size</strong> (<em>cellf</em>) – The resolution of the plot in the same units as the input file.</li>
<li><strong>return_plot</strong> – If true, returns a matplotlib plt object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">If return_plot == True, returns matplotlib plt object. Not yet implemented.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.Cloud.plot3d">
<code class="descname">plot3d</code><span class="sig-paren">(</span><em>point_size=1</em>, <em>cmap='Spectral_r'</em>, <em>max_points=500000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.Cloud.plot3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the three dimensional point cloud using a method suitable for non-Jupyter use (i.e. via the Python         console). By default, if the point cloud exceeds 5e5 points, then it is downsampled using a uniform random         distribution of 5e5 points. This is for performance purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point_size</strong> – The size of the rendered points.</li>
<li><strong>cmap</strong> – The matplotlib color map used to color the height distribution.</li>
<li><strong>max_points</strong> – The maximum number of points to render.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyfor.cloud.CloudData">
<em class="property">class </em><code class="descclassname">pyfor.cloud.</code><code class="descname">CloudData</code><span class="sig-paren">(</span><em>points</em>, <em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.CloudData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple class composed of a numpy array of points and a laspy header, meant for internal use. This is basically
a way to load data from the las file into memory.</p>
<dl class="method">
<dt id="pyfor.cloud.CloudData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>points</em>, <em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.CloudData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.cloud.CloudData.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.cloud.CloudData.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the points and header to a .las file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – The path of the .las file to write to.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyfor.filter">
<span id="pyfor-filter-module"></span><h2>pyfor.filter module<a class="headerlink" href="#module-pyfor.filter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyfor.filter.dhmax">
<code class="descclassname">pyfor.filter.</code><code class="descname">dhmax</code><span class="sig-paren">(</span><em>elev_array</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.filter.dhmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the maximum height difference for an elevation array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elev_array</strong> – </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyfor.filter.dht">
<code class="descclassname">pyfor.filter.</code><code class="descname">dht</code><span class="sig-paren">(</span><em>elev_array</em>, <em>w_k</em>, <em>w_k_1</em>, <em>dh_0</em>, <em>dh_max</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.filter.dht" title="Permalink to this definition">¶</a></dt>
<dd><p>”
Calculates dh_t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>elev_array</strong> – A 1D array of elevation values</li>
<li><strong>w_k</strong> – An integer representing the window size</li>
<li><strong>w_k_1</strong> – An integer representing the previous window size</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyfor.filter.slope">
<code class="descclassname">pyfor.filter.</code><code class="descname">slope</code><span class="sig-paren">(</span><em>elev_array</em>, <em>w_k</em>, <em>w_k_1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.filter.slope" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the slope coefficient.</p>
<p>Returns the slope coefficient s for a given elev_aray and w_k</p>
</dd></dl>

<dl class="function">
<dt id="pyfor.filter.window_size">
<code class="descclassname">pyfor.filter.</code><code class="descname">window_size</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.filter.window_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyfor.filter.zhang">
<code class="descclassname">pyfor.filter.</code><code class="descname">zhang</code><span class="sig-paren">(</span><em>array</em>, <em>number_of_windows</em>, <em>dh_max</em>, <em>dh_0</em>, <em>c</em>, <em>grid</em>, <em>interp_method='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.filter.zhang" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements Zhang et. al (2003), a progressive morphological ground filter. This returns a matrix of Z values for
each grid cell that have been determined to be actual ground cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>array</strong> – The array to interpolate on, usually an aggregate of the minimum Z value</td>
</tr>
</tbody>
</table>
<p>#TODO fix this to be max window size
:param number_of_windows:
:param dh_max: The maximum height threshold
:param dh_0: The starting null height threshold
:param c: The cell size used to construct the array
:param grid: The grid object used to construct the array
:return: An array corresponding to the filtered points, can be used to construct a DEM via the Raster class</p>
</dd></dl>

</div>
<div class="section" id="module-pyfor.gisexport">
<span id="pyfor-gisexport-module"></span><h2>pyfor.gisexport module<a class="headerlink" href="#module-pyfor.gisexport" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyfor.gisexport.array_to_polygons">
<code class="descclassname">pyfor.gisexport.</code><code class="descname">array_to_polygons</code><span class="sig-paren">(</span><em>array</em>, <em>affine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.gisexport.array_to_polygons" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geopandas dataframe of polygons as deduced from an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>array</strong> – The 2D numpy array to polygonize.</li>
<li><strong>affine</strong> – The affine transformation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyfor.gisexport.array_to_raster">
<code class="descclassname">pyfor.gisexport.</code><code class="descname">array_to_raster</code><span class="sig-paren">(</span><em>array</em>, <em>pixel_size</em>, <em>x_min</em>, <em>y_max</em>, <em>wkt</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.gisexport.array_to_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a GeoTIFF raster from a numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>array</strong> – 2D numpy array of cell values</li>
<li><strong>pixel_size</strong> – – Desired resolution of the output raster, in same units as wkt projection.</li>
<li><strong>x_min</strong> – Minimum x coordinate (top left corner of raster)</li>
<li><strong>y_max</strong> – Maximum y coordinate</li>
<li><strong>wkt</strong> – The wkt string with desired projection</li>
<li><strong>path</strong> – The output bath of the GeoTIFF</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyfor.plot">
<span id="pyfor-plot-module"></span><h2>pyfor.plot module<a class="headerlink" href="#module-pyfor.plot" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyfor.plot.iplot3d">
<code class="descclassname">pyfor.plot.</code><code class="descname">iplot3d</code><span class="sig-paren">(</span><em>las</em>, <em>max_points</em>, <em>point_size</em>, <em>dim</em>, <em>colorscale</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.plot.iplot3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the 3d point cloud in a compatible version for Jupyter notebooks.
:return:
# TODO refactor to a name that isn’t silly</p>
</dd></dl>

<dl class="function">
<dt id="pyfor.plot.iplot3d_surface">
<code class="descclassname">pyfor.plot.</code><code class="descname">iplot3d_surface</code><span class="sig-paren">(</span><em>array</em>, <em>colorscale</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.plot.iplot3d_surface" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pyfor.rasterizer">
<span id="pyfor-rasterizer-module"></span><h2>pyfor.rasterizer module<a class="headerlink" href="#module-pyfor.rasterizer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyfor.rasterizer.Grid">
<em class="property">class </em><code class="descclassname">pyfor.rasterizer.</code><code class="descname">Grid</code><span class="sig-paren">(</span><em>cloud</em>, <em>cell_size</em>, <em>voxelize='False'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Grid object is a representation of a point cloud that has been sorted into X and Y dimensional bins. It is     not quite a raster yet. A raster has only one value per cell, whereas the Grid object merely sorts all points     into their respective cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cloud</strong> – The “parent” cloud object.</li>
<li><strong>cell_size</strong> – The size of the cell for sorting in the units of the input cloud object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Returns a dataframe with sorted x and y with associated bins in a new columns</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyfor.rasterizer.Grid.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>cloud</em>, <em>cell_size</em>, <em>voxelize='False'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Grid.boolean_summary">
<code class="descname">boolean_summary</code><span class="sig-paren">(</span><em>func</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid.boolean_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a column in self.data that is a boolean of whether or not that point is the point that corresponds         to the function passed. For example, this can be used to create a boolean mask of points that are the minimum         z point in their respective cell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>func</strong> – The function to calculate on each group.</li>
<li><strong>dim</strong> – The dimension of the point cloud as a string (x, y or z)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyfor.rasterizer.Grid.empty_cells">
<code class="descname">empty_cells</code><a class="headerlink" href="#pyfor.rasterizer.Grid.empty_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the cells with no returns in self.data</p>
<p>return: An N x 2 numpy array where each row cooresponds to the [y x] coordinate of the empty cell.</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Grid.ground_filter">
<code class="descname">ground_filter</code><span class="sig-paren">(</span><em>num_windows</em>, <em>dh_max</em>, <em>dh_0</em>, <em>interp_method='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid.ground_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper call for filter.zhang with convenient defaults.</p>
<p>Returns a Raster object corresponding to the filtered ground DEM of this particular grid.
:param type:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Grid.interpolate">
<code class="descname">interpolate</code><span class="sig-paren">(</span><em>func</em>, <em>dim</em>, <em>interp_method='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates missing cells in the grid. This function uses scipy.griddata as a backend. Please see         documentation for that function for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> – The function (or function string) to calculate an array on the gridded data.</li>
<li><strong>dim</strong> – The dimension (i.e. column name of self.cells) to cast func onto.</li>
<li><strong>interp_method</strong> – The interpolation method call for scipy.griddata, one of any: “nearest”, “cubic”,         “linear”</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An interpolated array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Grid.metrics">
<code class="descname">metrics</code><span class="sig-paren">(</span><em>func_dict</em>, <em>as_raster=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid.metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates summary statistics for each grid cell in the Grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>func_dict</strong> – A dictionary containing keys corresponding to the columns of self.data and values that         correspond to the functions to be  called on those columns.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A pandas dataframe with the aggregated metrics.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Grid.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>num_windows</em>, <em>dh_max</em>, <em>dh_0</em>, <em>interp_method='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new, normalized Grid object.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Grid.raster">
<code class="descname">raster</code><span class="sig-paren">(</span><em>func</em>, <em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Grid.raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an m x n matrix with values as calculated for each cell in func. This is a raw array without         missing cells interpolated. See self.interpolate for interpolation methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> – A function string, i.e. “max” or a function itself, i.e. np.max. This function must be able to         take a 1D array of the given dimension as an input and produce a single value as an output. This single value         will become the value of each cell in the array.</li>
<li><strong>dim</strong> – The dimension to calculate on as a string, see the column names of self.data for a full list of         options</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A 2D numpy array where the value of each cell is the result of the passed function.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyfor.rasterizer.Raster">
<em class="property">class </em><code class="descclassname">pyfor.rasterizer.</code><code class="descname">Raster</code><span class="sig-paren">(</span><em>array</em>, <em>grid</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pyfor.rasterizer.Raster.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>array</em>, <em>grid</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Raster.iplot3d">
<code class="descname">iplot3d</code><span class="sig-paren">(</span><em>colorscale='Viridis'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster.iplot3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the raster as a surface using Plotly.</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Raster.local_maxima">
<code class="descname">local_maxima</code><span class="sig-paren">(</span><em>min_distance=2</em>, <em>threshold_abs=2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster.local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geopandas dataframe of points found using skimage.feature.peak_local_max
:return:</p>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Raster.pit_filter">
<code class="descname">pit_filter</code><span class="sig-paren">(</span><em>kernel_size</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster.pit_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters pits in the raster. Intended for use with canopy height models (i.e. grid(0.5).interpolate(“max”, “z”).
This function modifies the raster array <strong>in place</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kernel_size</strong> – The size of the kernel window to pass over the array. For example 3 -&gt; 3x3 kernel window.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Raster.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>cmap='viridis'</em>, <em>block=False</em>, <em>return_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Default plotting method for the Raster object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>block</strong> – An optional parameter, mostly for debugging purposes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Raster.watershed_seg">
<code class="descname">watershed_seg</code><span class="sig-paren">(</span><em>min_distance=2</em>, <em>threshold_abs=2</em>, <em>classify=False</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster.watershed_seg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the watershed segmentation of the Raster as a geopandas dataframe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>min_distance</strong> – The minimum distance between local height maxima in the same units as the input point         cloud.</li>
<li><strong>threshold_abs</strong> – The minimum threshold needed to be called a peak in peak_local_max.</li>
<li><strong>classify</strong> – If true, sets the user data of the original point cloud data to the segment ID. The         segment ID is an arbitrary identification number generated by the labels function. This can be useful for         plotting point clouds where each segment color is unique.</li>
<li><strong>plot</strong> – If plot is set to true then the segmentation will be plotted over the raster object..</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A geopandas data frame, each record is a crown segment.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfor.rasterizer.Raster.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfor.rasterizer.Raster.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the raster to a geotiff. Requires the Cloud.crs attribute to be filled by a projection string (ideally         wkt or proj4).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – The path to write to.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pyfor-test-module">
<h2>pyfor.test module<a class="headerlink" href="#pyfor-test-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyfor">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyfor" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Bryce Frank.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.2.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>